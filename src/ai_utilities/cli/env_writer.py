"""Environment file writer for .env operations.

Provides robust .env file creation and patching with comment preservation,
backup creation, and proper handling of provider-specific variables.
"""

import shutil
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from datetime import datetime


class EnvWriter:
    """Handles .env file operations with comment preservation and backups."""
    
    def __init__(self):
        """Initialize the environment writer."""
        self.header_comment = """# AI Utilities Environment Configuration
# Generated by ai-utilities setup on {timestamp}
# 
# Provider selection:
# - Single provider: AI_PROVIDER=<provider>
# - Multi-provider: AI_PROVIDER=auto + AI_AUTO_SELECT_ORDER=<csv>
# 
# Provider-specific variables take precedence over generic AI_* variables.
""".format(timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
    
    def create_or_patch(self, env_path: Path, config: Dict[str, Any]) -> None:
        """Create or patch .env file with provider configuration.
        
        Args:
            env_path: Path to .env file
            config: Configuration dictionary containing provider settings
        """
        if not isinstance(env_path, Path):
            env_path = Path(env_path)
        
        # Create backup if file exists
        if env_path.exists():
            self._create_backup(env_path)
        
        # Read existing content if patching
        existing_lines = []
        if env_path.exists():
            existing_lines = env_path.read_text().splitlines()
        
        # Generate new content lines
        new_lines = self._generate_content_lines(config)
        
        # Merge content (preserve comments, update variables)
        final_lines = self._merge_env_content(existing_lines, new_lines)
        
        # Write final content
        self._write_env_file(env_path, final_lines)
    
    def _create_backup(self, env_path: Path) -> None:
        """Create backup of existing .env file."""
        backup_path = env_path.with_suffix('.bak')
        shutil.copy2(env_path, backup_path)
    
    def _generate_content_lines(self, config: Dict[str, Any]) -> List[str]:
        """Generate content lines from configuration."""
        lines = []
        
        # Add header if creating new file
        lines.extend(self.header_comment.strip().split('\n'))
        lines.append("")  # Empty line after header
        
        # Handle provider configuration
        provider = config.get('provider', '')
        
        if provider == 'auto':
            # Multi-provider mode
            lines.append("# Multi-provider configuration")
            lines.append("AI_PROVIDER=auto")
            
            # Auto-select order
            auto_order = config.get('auto_select_order', [])
            if auto_order:
                lines.append(f"AI_AUTO_SELECT_ORDER={','.join(auto_order)}")
            
            lines.append("")
            
            # Individual provider configurations
            providers = config.get('providers', {})
            for provider_name, provider_config in providers.items():
                lines.extend(self._generate_provider_lines(provider_name, provider_config))
                lines.append("")
        
        else:
            # Single provider mode
            provider_name = config.get('provider', '')
            lines.append(f"# {provider_name.upper()} provider configuration")
            lines.append(f"AI_PROVIDER={provider}")
            lines.extend(self._generate_provider_lines(provider, config))
        
        return lines
    
    def _generate_provider_lines(self, provider_name: str, provider_config: Dict[str, Any]) -> List[str]:
        """Generate provider-specific configuration lines."""
        lines = []
        
        # Map provider names to environment variable prefixes
        prefix_map = {
            'openai': 'OPENAI',
            'groq': 'GROQ', 
            'together': 'TOGETHER',
            'openrouter': 'OPENROUTER',
            'deepseek': 'DEEPSEEK',
            'ollama': 'OLLAMA',
            'lmstudio': 'LMSTUDIO',
            'fastchat': 'FASTCHAT',
            'text-generation-webui': 'TEXT_GENERATION_WEBUI',
        }
        
        prefix = prefix_map.get(provider_name, provider_name.upper())
        
        # API key (if present)
        api_key = provider_config.get('api_key')
        if api_key:
            lines.append(f"{prefix}_API_KEY={api_key}")
        
        # Base URL
        base_url = provider_config.get('base_url')
        if base_url:
            lines.append(f"{prefix}_BASE_URL={base_url}")
        
        # Model
        model = provider_config.get('model')
        if model:
            lines.append(f"{prefix}_MODEL={model}")
        
        return lines
    
    def _merge_env_content(self, existing_lines: List[str], new_lines: List[str]) -> List[str]:
        """Merge existing and new content, preserving comments."""
        # Parse existing variables and comments
        existing_vars = {}
        existing_comments = []
        existing_other_lines = []  # Non-comment, non-var lines
        
        for line in existing_lines:
            line_stripped = line.strip()
            
            if not line_stripped or line_stripped.startswith('#'):
                # Preserve comments and empty lines
                existing_comments.append(line)
            elif '=' in line_stripped:
                # Parse variable
                key, value = line_stripped.split('=', 1)
                existing_vars[key.strip()] = value.strip()
            else:
                # Other lines (unlikely but handle them)
                existing_other_lines.append(line)
        
        # Parse new variables
        new_vars = {}
        new_header_lines = []
        
        in_header = False
        header_ended = False
        for line in new_lines:
            line_stripped = line.strip()
            
            if line_stripped.startswith('#'):
                new_header_lines.append(line)
                in_header = True
            elif line_stripped == '' and in_header:
                # Empty line after header ends the header section
                header_ended = True
                new_header_lines.append(line)
            elif '=' in line_stripped and (in_header or header_ended):
                # Variable line after header
                key, value = line_stripped.split('=', 1)
                new_vars[key.strip()] = value.strip()
                in_header = False  # Reset after first variable
            else:
                # Other lines (shouldn't happen but handle them)
                if in_header:
                    new_header_lines.append(line)
                else:
                    # This shouldn't happen in normal flow
                    pass
        
        # Merge variables (new ones override existing)
        merged_vars = {**existing_vars, **new_vars}
        
        # Build final content
        final_lines = []
        
        # Add new header (or preserve existing if no new header)
        if new_header_lines:
            # Check if existing content has a header we should preserve
            has_existing_header = any(
                line.strip().startswith('#') and 'AI Utilities' in line 
                for line in existing_comments
            )
            if has_existing_header:
                # Preserve existing header instead of using new one
                final_lines.extend(existing_comments)
            else:
                # Use new header
                final_lines.extend(new_header_lines)
        elif existing_comments:
            # Keep existing comments if no new header
            final_lines.extend(existing_comments)
        
        # Add merged variables in organized sections
        final_lines.extend(self._organize_variables(merged_vars))
        
        return final_lines
    
    def _organize_variables(self, variables: Dict[str, str]) -> List[str]:
        """Organize variables into logical sections."""
        # Define variable order and grouping
        section_order = [
            # Global configuration
            ['AI_PROVIDER', 'AI_AUTO_SELECT_ORDER', 'AI_MODEL', 'AI_LOG_LEVEL'],
            
            # Hosted providers (alphabetical)
            ['DEEPSEEK_API_KEY', 'DEEPSEEK_BASE_URL', 'DEEPSEEK_MODEL'],
            ['GROQ_API_KEY', 'GROQ_BASE_URL', 'GROQ_MODEL'],
            ['OPENAI_API_KEY', 'OPENAI_BASE_URL', 'OPENAI_MODEL'],
            ['OPENROUTER_API_KEY', 'OPENROUTER_BASE_URL', 'OPENROUTER_MODEL'],
            ['TOGETHER_API_KEY', 'TOGETHER_BASE_URL', 'TOGETHER_MODEL'],
            
            # Local providers (alphabetical)
            ['FASTCHAT_BASE_URL', 'FASTCHAT_MODEL'],
            ['LMSTUDIO_BASE_URL', 'LMSTUDIO_MODEL'],
            ['OLLAMA_BASE_URL', 'OLLAMA_MODEL'],
            ['TEXT_GENERATION_WEBUI_BASE_URL', 'TEXT_GENERATION_WEBUI_MODEL'],
            
            # Legacy/other
            ['AI_API_KEY', 'AI_BASE_URL'],
        ]
        
        organized_lines = []
        used_vars = set()
        
        # Add variables in defined order
        for section_vars in section_order:
            section_lines = []
            for var in section_vars:
                if var in variables and var not in used_vars:
                    section_lines.append(f"{var}={variables[var]}")
                    used_vars.add(var)
            
            if section_lines:
                organized_lines.extend(section_lines)
                organized_lines.append("")  # Empty line between sections
        
        # Add any remaining variables
        remaining_vars = [k for k in variables if k not in used_vars]
        if remaining_vars:
            for var in sorted(remaining_vars):
                organized_lines.append(f"{var}={variables[var]}")
            organized_lines.append("")
        
        # Remove trailing empty line
        if organized_lines and organized_lines[-1] == "":
            organized_lines.pop()
        
        return organized_lines
    
    def _write_env_file(self, env_path: Path, lines: List[str]) -> None:
        """Write content to .env file."""
        content = '\n'.join(lines)
        
        # Ensure file ends with single newline
        if content and not content.endswith('\n'):
            content += '\n'
        
        env_path.write_text(content)
    
    def read_env_vars(self, env_path: Path) -> Dict[str, str]:
        """Read environment variables from .env file.
        
        Args:
            env_path: Path to .env file
            
        Returns:
            Dictionary of environment variables
        """
        if not isinstance(env_path, Path):
            env_path = Path(env_path)
        
        vars_dict = {}
        
        if env_path.exists():
            content = env_path.read_text()
            for line in content.splitlines():
                line_stripped = line.strip()
                if line_stripped and not line_stripped.startswith('#') and '=' in line_stripped:
                    key, value = line_stripped.split('=', 1)
                    vars_dict[key.strip()] = value.strip()
        
        return vars_dict
